---
title: "Générateur de mots de passe sécurisé"
category: "best-practices"
description: "Guide sur la génération sécurisée de mots de passe : CSPRNG, entropie, longueur vs complexité, algorithmes, implémentations sécurisées, phrases de passe et bonnes pratiques."
coverImage: "/guides/password-gen.jpg"
date: "2024-03-08"
difficulty: "avancé"
readingTime: "40 min"
prerequisites: ["Nombres aléatoires", "Entropie", "Cryptographie"]
lastUpdated: "2024-12-19"
---

# Générateur de mots de passe sécurisé

La génération sécurisée de mots de passe est essentielle pour créer des mots de passe forts et imprévisibles. Une mauvaise génération peut compromettre complètement la sécurité, même si le mot de passe semble complexe.

## Introduction

Un générateur de mots de passe sécurisé doit :

1. Utiliser une source d'entropie cryptographiquement sécurisée
2. Générer des mots de passe avec une entropie suffisante
3. Éviter les patterns prévisibles
4. Permettre la personnalisation selon les besoins

## Entropie

L'entropie mesure l'imprévisibilité d'un mot de passe. Plus l'entropie est élevée, plus le mot de passe est résistant aux attaques par force brute.

### Formule

**Entropie = log₂(alphabet_size^length)**

### Exemples

```javascript
function calculateEntropy(length, alphabetSize) {
    return length * Math.log2(alphabetSize);
}

// 12 caractères, alphabet de 94 caractères
const entropy1 = calculateEntropy(12, 94);
console.log(entropy1); // ~78.5 bits

// 16 caractères, alphabet de 62 caractères (alphanumeric)
const entropy2 = calculateEntropy(16, 62);
console.log(entropy2); // ~95.3 bits
```

### Entropie minimale recommandée

- **Mots de passe utilisateur** : Minimum 60 bits
- **Clés cryptographiques** : Minimum 128 bits
- **Tokens de session** : Minimum 128 bits

## CSPRNG (Cryptographically Secure PRNG)

Utiliser exclusivement des générateurs cryptographiquement sécurisés.

### Sources d'entropie

#### Node.js

```javascript
const crypto = require('crypto');

function generateSecureRandom(length) {
    return crypto.randomBytes(length);
}

function generatePassword(length = 16) {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    const randomBytes = crypto.randomBytes(length);
    let password = '';
    
    for (let i = 0; i < length; i++) {
        password += alphabet[randomBytes[i] % alphabet.length];
    }
    
    return password;
}
```

#### JavaScript (navigateur)

```javascript
function generatePassword(length = 16) {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*';
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    
    let password = '';
    for (let i = 0; i < length; i++) {
        password += alphabet[array[i] % alphabet.length];
    }
    
    return password;
}
```

#### Python

```python
import secrets
import string

def generate_password(length=16):
    alphabet = string.ascii_letters + string.digits + string.punctuation
    return ''.join(secrets.choice(alphabet) for _ in range(length))
```

### ⚠️ Ne jamais utiliser

```javascript
// ❌ Math.random() - PRNG non sécurisé
function badGeneratePassword(length) {
    const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    let password = '';
    for (let i = 0; i < length; i++) {
        password += alphabet[Math.floor(Math.random() * alphabet.length)];
    }
    return password;
}
```

## Longueur vs Complexité

### Longueur : Plus importante

La longueur est généralement plus importante que la complexité pour la sécurité.

```javascript
// 20 caractères alphanumeriques
const longSimple = generatePassword(20, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789');
// Entropie : ~119 bits

// 12 caractères avec caractères spéciaux
const shortComplex = generatePassword(12, 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*');
// Entropie : ~78 bits
```

### Recommandations

- **Minimum** : 12 caractères
- **Recommandé** : 16+ caractères
- **Haute sécurité** : 20+ caractères

## Implémentation complète

### Générateur de base

```javascript
const crypto = require('crypto');

class SecurePasswordGenerator {
    constructor() {
        this.defaultAlphabet = {
            lowercase: 'abcdefghijklmnopqrstuvwxyz',
            uppercase: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ',
            digits: '0123456789',
            special: '!@#$%^&*()_+-=[]{}|;:,.<>?',
            all: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?'
        };
    }
    
    generate(options = {}) {
        const {
            length = 16,
            includeLowercase = true,
            includeUppercase = true,
            includeDigits = true,
            includeSpecial = true,
            excludeSimilar = false,
            excludeAmbiguous = false
        } = options;
        
        let alphabet = this.buildAlphabet({
            includeLowercase,
            includeUppercase,
            includeDigits,
            includeSpecial,
            excludeSimilar,
            excludeAmbiguous
        });
        
        if (alphabet.length === 0) {
            throw new Error('Alphabet cannot be empty');
        }
        
        return this.generateFromAlphabet(alphabet, length);
    }
    
    buildAlphabet(options) {
        let alphabet = '';
        
        if (options.includeLowercase) {
            alphabet += this.defaultAlphabet.lowercase;
        }
        if (options.includeUppercase) {
            alphabet += this.defaultAlphabet.uppercase;
        }
        if (options.includeDigits) {
            alphabet += this.defaultAlphabet.digits;
        }
        if (options.includeSpecial) {
            alphabet += this.defaultAlphabet.special;
        }
        
        if (options.excludeSimilar) {
            alphabet = alphabet.replace(/[il1Lo0O]/g, '');
        }
        
        if (options.excludeAmbiguous) {
            alphabet = alphabet.replace(/[{}[\]()\/\\'"~,;.<>]/g, '');
        }
        
        return alphabet;
    }
    
    generateFromAlphabet(alphabet, length) {
        const randomBytes = crypto.randomBytes(length);
        let password = '';
        
        for (let i = 0; i < length; i++) {
            password += alphabet[randomBytes[i] % alphabet.length];
        }
        
        return password;
    }
    
    calculateEntropy(password, alphabet) {
        const length = password.length;
        const alphabetSize = alphabet.length;
        return length * Math.log2(alphabetSize);
    }
}
```

### Générateur avec garanties

```javascript
class GuaranteedPasswordGenerator extends SecurePasswordGenerator {
    generate(options = {}) {
        const {
            length = 16,
            minLowercase = 1,
            minUppercase = 1,
            minDigits = 1,
            minSpecial = 1
        } = options;
        
        let password = '';
        let attempts = 0;
        const maxAttempts = 100;
        
        while (attempts < maxAttempts) {
            password = super.generate(options);
            
            if (this.meetsRequirements(password, {
                minLowercase,
                minUppercase,
                minDigits,
                minSpecial
            })) {
                return password;
            }
            
            attempts++;
        }
        
        throw new Error('Failed to generate password meeting requirements');
    }
    
    meetsRequirements(password, requirements) {
        const counts = {
            lowercase: (password.match(/[a-z]/g) || []).length,
            uppercase: (password.match(/[A-Z]/g) || []).length,
            digits: (password.match(/[0-9]/g) || []).length,
            special: (password.match(/[^a-zA-Z0-9]/g) || []).length
        };
        
        return (
            counts.lowercase >= requirements.minLowercase &&
            counts.uppercase >= requirements.minUppercase &&
            counts.digits >= requirements.minDigits &&
            counts.special >= requirements.minSpecial
        );
    }
}
```

## Phrases de passe (Passphrases)

Les phrases de passe utilisent plusieurs mots aléatoires au lieu de caractères aléatoires.

### Avantages

- Plus facile à retenir
- Entropie élevée avec des mots simples
- Résistant aux attaques par dictionnaire (si mots aléatoires)

### Génération

```javascript
class PassphraseGenerator {
    constructor(wordList) {
        this.wordList = wordList || this.getDefaultWordList();
    }
    
    generate(options = {}) {
        const {
            wordCount = 4,
            separator = ' ',
            capitalize = false,
            includeNumber = false,
            includeSpecial = false
        } = options;
        
        const words = [];
        const randomBytes = crypto.randomBytes(wordCount * 2);
        
        for (let i = 0; i < wordCount; i++) {
            const index = (randomBytes[i * 2] << 8) | randomBytes[i * 2 + 1];
            const word = this.wordList[index % this.wordList.length];
            words.push(capitalize ? this.capitalize(word) : word);
        }
        
        let passphrase = words.join(separator);
        
        if (includeNumber) {
            const number = crypto.randomInt(0, 100);
            passphrase += separator + number;
        }
        
        if (includeSpecial) {
            const special = '!@#$%^&*';
            const randomSpecial = special[crypto.randomInt(0, special.length)];
            passphrase += separator + randomSpecial;
        }
        
        return passphrase;
    }
    
    capitalize(word) {
        return word.charAt(0).toUpperCase() + word.slice(1);
    }
    
    getDefaultWordList() {
        return [
            'correct', 'horse', 'battery', 'staple',
            'apple', 'banana', 'cherry', 'date',
            'elephant', 'giraffe', 'hippo', 'jaguar'
        ];
    }
    
    calculateEntropy(wordCount, wordListSize = 7776) {
        return wordCount * Math.log2(wordListSize);
    }
}
```

### Diceware

Méthode standard pour générer des phrases de passe sécurisées.

```javascript
class DicewareGenerator {
    constructor() {
        this.wordList = this.loadDicewareWordList();
    }
    
    generate(wordCount = 5) {
        const words = [];
        
        for (let i = 0; i < wordCount; i++) {
            const diceRolls = this.rollDice(5);
            const word = this.wordList[diceRolls];
            words.push(word);
        }
        
        return words.join(' ');
    }
    
    rollDice(count) {
        let result = '';
        for (let i = 0; i < count; i++) {
            result += crypto.randomInt(1, 7).toString();
        }
        return result;
    }
    
    loadDicewareWordList() {
        return require('./diceware-wordlist.json');
    }
}
```

## Validation de force

```javascript
class PasswordValidator {
    validate(password, options = {}) {
        const {
            minLength = 12,
            minEntropy = 60,
            requireLowercase = true,
            requireUppercase = true,
            requireDigits = true,
            requireSpecial = false
        } = options;
        
        const errors = [];
        
        if (password.length < minLength) {
            errors.push(`Password must be at least ${minLength} characters`);
        }
        
        const entropy = this.calculateEntropy(password);
        if (entropy < minEntropy) {
            errors.push(`Password entropy (${entropy.toFixed(1)} bits) is below minimum (${minEntropy} bits)`);
        }
        
        if (requireLowercase && !/[a-z]/.test(password)) {
            errors.push('Password must contain lowercase letters');
        }
        
        if (requireUppercase && !/[A-Z]/.test(password)) {
            errors.push('Password must contain uppercase letters');
        }
        
        if (requireDigits && !/[0-9]/.test(password)) {
            errors.push('Password must contain digits');
        }
        
        if (requireSpecial && !/[^a-zA-Z0-9]/.test(password)) {
            errors.push('Password must contain special characters');
        }
        
        return {
            valid: errors.length === 0,
            errors,
            entropy: entropy,
            strength: this.calculateStrength(entropy)
        };
    }
    
    calculateEntropy(password) {
        const alphabetSize = this.calculateAlphabetSize(password);
        return password.length * Math.log2(alphabetSize);
    }
    
    calculateAlphabetSize(password) {
        let size = 0;
        if (/[a-z]/.test(password)) size += 26;
        if (/[A-Z]/.test(password)) size += 26;
        if (/[0-9]/.test(password)) size += 10;
        if (/[^a-zA-Z0-9]/.test(password)) size += 32;
        return size || 1;
    }
    
    calculateStrength(entropy) {
        if (entropy < 28) return 'Très faible';
        if (entropy < 36) return 'Faible';
        if (entropy < 60) return 'Moyen';
        if (entropy < 128) return 'Fort';
        return 'Très fort';
    }
}
```

## Bonnes pratiques

### Checklist de sécurité

- [ ] Utiliser exclusivement des CSPRNG
- [ ] Générer des mots de passe avec entropie suffisante (minimum 60 bits)
- [ ] Éviter les patterns prévisibles
- [ ] Ne jamais réutiliser de mots de passe
- [ ] Utiliser des longueurs appropriées (12+ caractères)
- [ ] Valider la force des mots de passe générés
- [ ] Tester les générateurs régulièrement
- [ ] Documenter les algorithmes utilisés
- [ ] Ne jamais logger ou stocker les mots de passe générés
- [ ] Utiliser des bibliothèques cryptographiques réputées
- [ ] Éviter les implémentations personnalisées si possible
- [ ] Former les utilisateurs sur la génération sécurisée

## Conclusion

La génération sécurisée de mots de passe nécessite des sources d'entropie cryptographiquement sécurisées, une longueur suffisante, et l'évitement des patterns prévisibles. Les phrases de passe offrent une alternative plus mémorisable avec une sécurité équivalente ou supérieure.

## Références techniques

- [NIST SP 800-63B - Digital Identity Guidelines](https://pages.nist.gov/800-63-3/)
- [OWASP Password Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html)
- [Diceware Passphrase](https://theworld.com/~reinhold/diceware.html)
- [RFC 4086 - Randomness Requirements for Security](https://tools.ietf.org/html/rfc4086)
