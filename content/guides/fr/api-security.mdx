---
title: "Sécurisation des APIs"
category: "best-practices"
description: "Guide sur la sécurisation des APIs REST : authentification (JWT, OAuth), rate limiting, validation, CORS, logging, monitoring, versioning, documentation, bonnes pratiques et implémentations sécurisées."
coverImage: "/guides/api.jpg"
date: "2024-03-20"
difficulty: "avancé"
readingTime: "45 min"
prerequisites: ["Développement web", "REST APIs", "Concepts de sécurité"]
lastUpdated: "2024-12-19"
---

# Sécurisation des APIs

Les APIs REST sont devenues le standard pour l'intégration entre systèmes. Cependant, elles représentent également des cibles privilégiées pour les attaquants. Une sécurisation appropriée est essentielle pour protéger les données et les fonctionnalités exposées.

## Introduction

Les APIs modernes doivent faire face à de nombreux défis de sécurité :

- **Authentification et autorisation** : Vérifier l'identité et les permissions
- **Rate limiting** : Prévenir les abus et attaques DDoS
- **Validation des entrées** : Protéger contre les injections
- **CORS** : Contrôler les accès cross-origin
- **Logging et monitoring** : Détecter les anomalies
- **Versioning** : Gérer les évolutions sans compromettre la sécurité

## Authentification des APIs

### JWT pour les APIs

```javascript
const jwt = require('jsonwebtoken');
const express = require('express');

class APIAuthService {
    generateToken(user) {
        return jwt.sign(
            {
                userId: user.id,
                role: user.role,
                apiAccess: true
            },
            process.env.JWT_SECRET,
            {
                expiresIn: '1h',
                algorithm: 'HS256',
                issuer: 'api.myapp.com',
                audience: 'api.myapp.com'
            }
        );
    }
    
    verifyToken(token) {
        try {
            return jwt.verify(token, process.env.JWT_SECRET, {
                algorithms: ['HS256'],
                issuer: 'api.myapp.com',
                audience: 'api.myapp.com'
            });
        } catch (error) {
            throw new Error('Invalid token');
        }
    }
}

// Middleware d'authentification
function authenticateAPI(req, res, next) {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Missing or invalid authorization header' });
    }
    
    const token = authHeader.substring(7);
    const authService = new APIAuthService();
    
    try {
        const decoded = authService.verifyToken(token);
        req.user = decoded;
        next();
    } catch (error) {
        res.status(401).json({ error: 'Invalid token' });
    }
}

app.get('/api/users', authenticateAPI, async (req, res) => {
    const users = await db.getUsers();
    res.json(users);
});
```

### API Keys

```javascript
class APIKeyService {
    async generateAPIKey(userId, name) {
        const key = crypto.randomBytes(32).toString('hex');
        const hashedKey = crypto.createHash('sha256').update(key).digest('hex');
        
        await db.storeAPIKey({
            userId,
            name,
            hashedKey,
            createdAt: new Date(),
            lastUsed: null
        });
        
        return key;
    }
    
    async validateAPIKey(apiKey) {
        const hashedKey = crypto.createHash('sha256').update(apiKey).digest('hex');
        const keyRecord = await db.getAPIKey(hashedKey);
        
        if (!keyRecord || !keyRecord.isActive) {
            return null;
        }
        
        await db.updateAPIKeyLastUsed(keyRecord.id);
        return keyRecord;
    }
}

function authenticateAPIKey(req, res, next) {
    const apiKey = req.headers['x-api-key'];
    
    if (!apiKey) {
        return res.status(401).json({ error: 'Missing API key' });
    }
    
    const keyService = new APIKeyService();
    keyService.validateAPIKey(apiKey)
        .then(keyRecord => {
            if (!keyRecord) {
                return res.status(401).json({ error: 'Invalid API key' });
            }
            
            req.apiKey = keyRecord;
            next();
        })
        .catch(error => {
            res.status(500).json({ error: 'Authentication error' });
        });
}
```

### OAuth 2.0 pour les APIs

```javascript
function authenticateOAuth(req, res, next) {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Missing authorization header' });
    }
    
    const accessToken = authHeader.substring(7);
    
    verifyOAuthToken(accessToken)
        .then(tokenInfo => {
            req.user = tokenInfo.user;
            req.scopes = tokenInfo.scopes;
            next();
        })
        .catch(error => {
            res.status(401).json({ error: 'Invalid token' });
        });
}

function requireScope(scope) {
    return (req, res, next) => {
        if (!req.scopes || !req.scopes.includes(scope)) {
            return res.status(403).json({ 
                error: 'Insufficient permissions',
                required: scope
            });
        }
        next();
    };
}

app.get('/api/users',
    authenticateOAuth,
    requireScope('users:read'),
    async (req, res) => {
        const users = await db.getUsers();
        res.json(users);
    }
);
```

## Rate Limiting

### Implémentation de base

```javascript
const rateLimit = require('express-rate-limit');

const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    max: 100,
    message: 'Too many requests from this IP, please try again later',
    standardHeaders: true,
    legacyHeaders: false
});

app.use('/api/', apiLimiter);
```

### Rate limiting par utilisateur

```javascript
const RedisStore = require('rate-limit-redis');
const redis = require('redis');

const redisClient = redis.createClient();

const userLimiter = rateLimit({
    store: new RedisStore({
        client: redisClient,
        prefix: 'rl:user:'
    }),
    windowMs: 60 * 1000,
    max: async (req) => {
        if (req.user && req.user.role === 'premium') {
            return 1000;
        }
        return 100;
    },
    keyGenerator: (req) => {
        return req.user ? req.user.id : req.ip;
    },
    message: 'Rate limit exceeded'
});
```

### Rate limiting par endpoint

```javascript
const createLimiter = (windowMs, max) => {
    return rateLimit({
        windowMs,
        max,
        standardHeaders: true
    });
};

const strictLimiter = createLimiter(15 * 60 * 1000, 10);
const normalLimiter = createLimiter(15 * 60 * 1000, 100);

app.post('/api/login', strictLimiter, loginHandler);
app.post('/api/register', strictLimiter, registerHandler);
app.get('/api/users', normalLimiter, getUsersHandler);
```

### Rate limiting avec sliding window

```javascript
class SlidingWindowRateLimiter {
    constructor(redis, windowMs, maxRequests) {
        this.redis = redis;
        this.windowMs = windowMs;
        this.maxRequests = maxRequests;
    }
    
    async checkLimit(identifier) {
        const key = `rate_limit:${identifier}`;
        const now = Date.now();
        const windowStart = now - this.windowMs;
        
        await this.redis.zremrangebyscore(key, 0, windowStart);
        
        const count = await this.redis.zcard(key);
        
        if (count >= this.maxRequests) {
            return {
                allowed: false,
                remaining: 0,
                resetTime: await this.redis.zrange(key, 0, 0, 'WITHSCORES')
            };
        }
        
        await this.redis.zadd(key, now, `${now}-${Math.random()}`);
        await this.redis.expire(key, Math.floor(this.windowMs / 1000));
        
        return {
            allowed: true,
            remaining: this.maxRequests - count - 1,
            resetTime: now + this.windowMs
        };
    }
}
```

## Validation des entrées

### Validation avec Zod

```javascript
const { z } = require('zod');

const createUserSchema = z.object({
    username: z.string()
        .min(3)
        .max(50)
        .regex(/^[a-zA-Z0-9_]+$/),
    email: z.string().email(),
    password: z.string()
        .min(12)
        .regex(/[a-z]/)
        .regex(/[A-Z]/)
        .regex(/[0-9]/)
        .regex(/[^a-zA-Z0-9]/),
    age: z.number().int().min(18).max(120),
    role: z.enum(['user', 'admin']).optional()
});

app.post('/api/users', async (req, res) => {
    try {
        const validated = createUserSchema.parse(req.body);
        const user = await db.createUser(validated);
        res.status(201).json(user);
    } catch (error) {
        if (error instanceof z.ZodError) {
            return res.status(400).json({
                error: 'Validation failed',
                details: error.errors
            });
        }
        res.status(500).json({ error: 'Server error' });
    }
});
```

### Validation de paramètres de requête

```javascript
const querySchema = z.object({
    page: z.string().regex(/^\d+$/).transform(Number).default('1'),
    limit: z.string().regex(/^\d+$/).transform(Number).default('10'),
    sort: z.enum(['asc', 'desc']).default('asc'),
    filter: z.string().optional()
});

app.get('/api/users', async (req, res) => {
    try {
        const query = querySchema.parse(req.query);
        
        if (query.limit > 100) {
            return res.status(400).json({ error: 'Limit cannot exceed 100' });
        }
        
        const users = await db.getUsers({
            page: query.page,
            limit: query.limit,
            sort: query.sort,
            filter: query.filter
        });
        
        res.json(users);
    } catch (error) {
        res.status(400).json({ error: 'Invalid query parameters' });
    }
});
```

### Sanitization

```javascript
const DOMPurify = require('isomorphic-dompurify');
const validator = require('validator');

function sanitizeInput(input, type) {
    if (typeof input !== 'string') {
        return input;
    }
    
    switch (type) {
        case 'html':
            return DOMPurify.sanitize(input, { ALLOWED_TAGS: [] });
        case 'email':
            return validator.normalizeEmail(input);
        case 'url':
            return validator.escape(input);
        case 'text':
            return validator.escape(input);
        default:
            return input;
    }
}

app.post('/api/posts', async (req, res) => {
    const post = {
        title: sanitizeInput(req.body.title, 'text'),
        content: sanitizeInput(req.body.content, 'html'),
        authorEmail: sanitizeInput(req.body.authorEmail, 'email')
    };
    
    const created = await db.createPost(post);
    res.status(201).json(created);
});
```

## CORS (Cross-Origin Resource Sharing)

### Configuration sécurisée

```javascript
const cors = require('cors');

const corsOptions = {
    origin: (origin, callback) => {
        const allowedOrigins = [
            'https://myapp.com',
            'https://admin.myapp.com'
        ];
        
        if (!origin || allowedOrigins.includes(origin)) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-API-Key'],
    exposedHeaders: ['X-Total-Count', 'X-Page'],
    maxAge: 86400
};

app.use('/api/', cors(corsOptions));
```

### CORS dynamique

```javascript
async function getCorsOptions(req) {
    const origin = req.headers.origin;
    
    if (!origin) {
        return { origin: false };
    }
    
    const allowedDomain = await db.getAllowedDomain(origin);
    
    if (!allowedDomain || !allowedDomain.isActive) {
        return { origin: false };
    }
    
    return {
        origin: origin,
        credentials: true,
        methods: allowedDomain.allowedMethods || ['GET', 'POST'],
        allowedHeaders: allowedDomain.allowedHeaders || ['Content-Type', 'Authorization']
    };
}

app.use('/api/', cors(getCorsOptions));
```

## Logging et monitoring

### Logging structuré

```javascript
const winston = require('winston');

const logger = winston.createLogger({
    level: 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.json()
    ),
    transports: [
        new winston.transports.File({ filename: 'api-error.log', level: 'error' }),
        new winston.transports.File({ filename: 'api.log' })
    ]
});

function logAPIRequest(req, res, next) {
    const startTime = Date.now();
    
    res.on('finish', () => {
        const duration = Date.now() - startTime;
        
        logger.info('API request', {
            method: req.method,
            path: req.path,
            statusCode: res.statusCode,
            duration,
            ipAddress: req.ip,
            userAgent: req.get('user-agent'),
            userId: req.user?.id,
            apiKey: req.apiKey?.id
        });
    });
    
    next();
}

app.use('/api/', logAPIRequest);
```

### Détection d'anomalies

```javascript
class AnomalyDetection {
    constructor(redis) {
        this.redis = redis;
    }
    
    async detectAnomalies(req) {
        const anomalies = [];
        
        const requestRate = await this.checkRequestRate(req.ip);
        if (requestRate > 1000) {
            anomalies.push({
                type: 'high_request_rate',
                severity: 'high',
                value: requestRate
            });
        }
        
        const errorRate = await this.checkErrorRate(req.ip);
        if (errorRate > 0.5) {
            anomalies.push({
                type: 'high_error_rate',
                severity: 'medium',
                value: errorRate
            });
        }
        
        const suspiciousPatterns = this.detectSuspiciousPatterns(req);
        if (suspiciousPatterns.length > 0) {
            anomalies.push({
                type: 'suspicious_patterns',
                severity: 'high',
                patterns: suspiciousPatterns
            });
        }
        
        if (anomalies.length > 0) {
            await this.alert(anomalies, req);
        }
        
        return anomalies;
    }
    
    detectSuspiciousPatterns(req) {
        const patterns = [];
        
        const sqlPatterns = [
            /(\b(SELECT|INSERT|UPDATE|DELETE|DROP)\b)/i,
            /(--|;|\/\*|\*\/)/
        ];
        
        const bodyString = JSON.stringify(req.body);
        for (const pattern of sqlPatterns) {
            if (pattern.test(bodyString)) {
                patterns.push('sql_injection_attempt');
            }
        }
        
        const xssPatterns = [
            /<script/i,
            /javascript:/i,
            /on\w+\s*=/i
        ];
        
        for (const pattern of xssPatterns) {
            if (pattern.test(bodyString)) {
                patterns.push('xss_attempt');
            }
        }
        
        return patterns;
    }
}
```

## Versioning des APIs

### Versioning par URL

```javascript
app.use('/api/v1', v1Router);
app.use('/api/v2', v2Router);

const v1Router = express.Router();
v1Router.get('/users', async (req, res) => {
    const users = await db.getUsers();
    res.json(users);
});

const v2Router = express.Router();
v2Router.get('/users', async (req, res) => {
    const users = await db.getUsers();
    res.json({
        data: users,
        meta: {
            version: '2.0',
            pagination: {
                page: 1,
                total: users.length
            }
        }
    });
});
```

### Versioning par header

```javascript
function versionMiddleware(req, res, next) {
    const apiVersion = req.headers['api-version'] || '1.0';
    req.apiVersion = apiVersion;
    next();
}

app.use('/api/', versionMiddleware);

app.get('/api/users', async (req, res) => {
    if (req.apiVersion === '2.0') {
        const users = await db.getUsers();
        res.json({
            data: users,
            meta: { version: '2.0' }
        });
    } else {
        const users = await db.getUsers();
        res.json(users);
    }
});
```

## Documentation de sécurité

### OpenAPI avec sécurité

```yaml
openapi: 3.0.0
info:
  title: My API
  version: 1.0.0
paths:
  /users:
    get:
      security:
        - bearerAuth: []
      responses:
        '200':
          description: Success
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
    apiKey:
      type: apiKey
      in: header
      name: X-API-Key
```

## Bonnes pratiques

### Checklist de sécurité API

- [ ] Utiliser HTTPS uniquement
- [ ] Implémenter l'authentification (JWT, OAuth, API Keys)
- [ ] Valider toutes les entrées
- [ ] Implémenter le rate limiting
- [ ] Configurer CORS correctement
- [ ] Logger toutes les requêtes
- [ ] Monitorer les anomalies
- [ ] Versionner les APIs
- [ ] Documenter la sécurité (OpenAPI)
- [ ] Implémenter la pagination
- [ ] Limiter la taille des payloads
- [ ] Utiliser des codes de statut HTTP appropriés
- [ ] Ne jamais exposer d'informations sensibles dans les erreurs
- [ ] Implémenter la révocation de tokens
- [ ] Utiliser des scopes OAuth pour les permissions
- [ ] Chiffrer les données sensibles en transit et au repos
- [ ] Implémenter la détection d'intrusion
- [ ] Effectuer des audits de sécurité réguliers
- [ ] Tester les APIs avec des outils de sécurité
- [ ] Maintenir les dépendances à jour

## Conclusion

La sécurisation des APIs nécessite une approche en couches :

1. **Authentification robuste** : JWT, OAuth, API Keys
2. **Rate limiting** : Prévenir les abus
3. **Validation stricte** : Protéger contre les injections
4. **CORS approprié** : Contrôler les accès cross-origin
5. **Logging et monitoring** : Détecter les anomalies
6. **Versioning** : Gérer les évolutions

Une implémentation correcte de ces techniques offre une protection robuste pour les APIs.

## Références techniques

- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
- [OWASP REST Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html)
- [RFC 7231 - HTTP/1.1 Semantics](https://tools.ietf.org/html/rfc7231)
- [OpenAPI Specification](https://swagger.io/specification/)
- [JSON Web Token (JWT)](https://jwt.io/)
- [OAuth 2.0](https://oauth.net/2/)
