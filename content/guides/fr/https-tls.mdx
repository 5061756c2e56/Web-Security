---
title: "HTTPS et TLS du protocole de sécurité"
category: "web-security"
description: "Guide sur HTTPS et TLS : handshake détaillé, versions TLS, cipher suites, HSTS, certificate pinning, vulnérabilités TLS, configuration sécurisée et bonnes pratiques."
coverImage: "/guides/https.jpg"
date: "2024-03-17"
difficulty: "avancé"
readingTime: "45 min"
prerequisites: ["Cryptographie", "Réseaux", "Certificats SSL/TLS"]
lastUpdated: "2024-12-19"
---

# HTTPS et TLS du protocole de sécurité

HTTPS (HTTP Secure) combine le protocole HTTP avec TLS (Transport Layer Security) pour chiffrer les communications web. TLS est le successeur de SSL et constitue le standard actuel pour sécuriser les communications sur Internet.

## Introduction

TLS fournit trois services essentiels :

1. **Authentification** : Vérification de l'identité du serveur (et optionnellement du client)
2. **Confidentialité** : Chiffrement des données en transit
3. **Intégrité** : Détection des modifications des données

### Pourquoi HTTPS est essentiel

- Protection contre l'écoute passive (eavesdropping)
- Protection contre les attaques man-in-the-middle
- Intégrité des données
- Authentification du serveur
- Amélioration du SEO (Google favorise HTTPS)
- Conformité aux réglementations (RGPD, PCI-DSS)

## Handshake TLS détaillé

### TLS 1.2 Handshake

```
Client                          Server
  |                                |
  |--- Client Hello -------------->|
  |   - TLS version                |
  |   - Cipher suites              |
  |   - Random (ClientHello.random)|
  |   - Compression methods        |
  |   - Extensions                 |
  |                                |
  |<-- Server Hello --------------|
  |   - TLS version                |
  |   - Cipher suite               |
  |   - Random (ServerHello.random)|
  |   - Compression method         |
  |                                |
  |<-- Certificate ----------------|
  |   - Server certificate         |
  |   - Certificate chain          |
  |                                |
  |<-- Server Key Exchange --------| (si nécessaire)
  |   - Public key                  |
  |                                |
  |<-- Server Hello Done ----------|
  |                                |
  |--- Client Key Exchange ------->|
  |   - Pre-master secret          |
  |   (chiffré avec clé publique)  |
  |                                |
  |--- Change Cipher Spec -------->|
  |                                |
  |--- Finished ------------------>|
  |   (chiffré avec clés de session)|
  |                                |
  |<-- Change Cipher Spec ---------|
  |                                |
  |<-- Finished --------------------|
  |   (chiffré avec clés de session)|
  |                                |
  |=== Communication chiffrée ====|
```

### TLS 1.3 Handshake (simplifié)

```
Client                          Server
  |                                |
  |--- Client Hello -------------->|
  |   - Supported versions         |
  |   - Key share (clé publique)   |
  |   - Cipher suites              |
  |                                |
  |<-- Server Hello ----------------|
  |   - Selected version            |
  |   - Key share (clé publique)   |
  |   - Cipher suite                |
  |   - Certificate                 |
  |   - Certificate Verify          |
  |   - Finished                    |
  |                                |
  |--- Finished ------------------>|
  |                                |
  |=== Communication chiffrée ====|
```

### Implémentation du handshake

```javascript
const tls = require('tls');
const crypto = require('crypto');

class TLSHandshake {
    constructor() {
        this.clientRandom = crypto.randomBytes(32);
        this.serverRandom = null;
        this.preMasterSecret = null;
        this.masterSecret = null;
    }
    
    generateClientHello() {
        return {
            version: { major: 3, minor: 3 },
            random: this.clientRandom,
            cipherSuites: [
                'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384',
                'TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384',
                'TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256'
            ],
            compressionMethods: [0],
            extensions: {
                server_name: 'example.com',
                supported_groups: ['x25519', 'secp256r1'],
                signature_algorithms: ['rsa_pss_rsae_sha256', 'ecdsa_secp256r1_sha256']
            }
        };
    }
    
    generatePreMasterSecret() {
        this.preMasterSecret = crypto.randomBytes(48);
        return this.preMasterSecret;
    }
    
    deriveMasterSecret(preMasterSecret, serverRandom) {
        this.serverRandom = serverRandom;
        
        const seed = Buffer.concat([
            Buffer.from('master secret'),
            this.clientRandom,
            serverRandom
        ]);
        
        this.masterSecret = this.PRF(preMasterSecret, 'master secret', seed, 48);
        return this.masterSecret;
    }
    
    deriveKeyMaterial(masterSecret, label, seed, length) {
        return this.PRF(masterSecret, label, seed, length);
    }
    
    PRF(secret, label, seed, length) {
        const hmac = crypto.createHmac('sha256', secret);
        hmac.update(label);
        hmac.update(seed);
        return hmac.digest().slice(0, length);
    }
}
```

## Versions TLS

### TLS 1.0 et 1.1

**Statut :** Obsolètes et dépréciés

**Problèmes :**
- Vulnérables à plusieurs attaques
- Utilisation de MD5 et SHA-1
- Pas de support des cipher suites modernes

**Recommandation :** Ne pas utiliser

### TLS 1.2

**Statut :** Standard actuel, sécurisé

**Caractéristiques :**
- Support des algorithmes modernes (AES-GCM, ChaCha20-Poly1305)
- Authenticated Encryption
- Extensions flexibles

**Configuration recommandée :**

```javascript
const https = require('https');
const tls = require('tls');

const options = {
    minVersion: 'TLSv1.2',
    maxVersion: 'TLSv1.3',
    ciphers: [
        'ECDHE-RSA-AES128-GCM-SHA256',
        'ECDHE-ECDSA-AES128-GCM-SHA256',
        'ECDHE-RSA-AES256-GCM-SHA384',
        'ECDHE-ECDSA-AES256-GCM-SHA384',
        'ECDHE-RSA-CHACHA20-POLY1305',
        'ECDHE-ECDSA-CHACHA20-POLY1305',
        '!aNULL',
        '!eNULL',
        '!EXPORT',
        '!DES',
        '!RC4',
        '!MD5',
        '!PSK',
        '!SRP',
        '!CAMELLIA'
    ].join(':'),
    honorCipherOrder: true
};
```

### TLS 1.3

**Statut :** Moderne, recommandé

**Améliorations :**
- Handshake plus rapide (1 RTT au lieu de 2)
- Suppression des algorithmes faibles
- Forward secrecy obligatoire
- 0-RTT pour les connexions répétées (avec précaution)

**Configuration :**

```javascript
const options = {
    minVersion: 'TLSv1.3',
    maxVersion: 'TLSv1.3',
    ciphers: 'TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256'
};
```

## Cipher Suites

### Structure

```
TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
  |     |     |     |     |     |
  |     |     |     |     |     +-- Hash/MAC
  |     |     |     |     +-------- Mode de chiffrement
  |     |     |     +-------------- Algorithme de chiffrement
  |     |     +-------------------- Algorithme d'authentification
  |     +-------------------------- Méthode d'échange de clés
  +-------------------------------- Protocole
```

### Composants

#### Échange de clés

- **RSA** : Chiffrement avec clé publique RSA
- **ECDHE** : Ephemeral Elliptic Curve Diffie-Hellman (recommandé)
- **DHE** : Ephemeral Diffie-Hellman
- **ECDH** : Elliptic Curve Diffie-Hellman (non-ephemeral)

#### Authentification

- **RSA** : Signature RSA
- **ECDSA** : Signature à courbe elliptique
- **DSA** : Digital Signature Algorithm (obsolète)

#### Chiffrement

- **AES-128/256** : Advanced Encryption Standard
- **ChaCha20** : Chiffrement de flux moderne
- **Camellia** : Alternative à AES
- **3DES** : Triple DES (obsolète)
- **RC4** : Obsolète et vulnérable

#### Intégrité/MAC

- **GCM** : Galois/Counter Mode (AEAD)
- **Poly1305** : MAC moderne (avec ChaCha20)
- **SHA-256/384** : Secure Hash Algorithm
- **SHA-1** : Obsolète et vulnérable
- **MD5** : Obsolète et vulnérable

### Cipher suites recommandées

**TLS 1.2 :**
```
ECDHE-RSA-AES128-GCM-SHA256
ECDHE-ECDSA-AES128-GCM-SHA256
ECDHE-RSA-AES256-GCM-SHA384
ECDHE-ECDSA-AES256-GCM-SHA384
ECDHE-RSA-CHACHA20-POLY1305
ECDHE-ECDSA-CHACHA20-POLY1305
```

**TLS 1.3 :**
```
TLS_AES_256_GCM_SHA384
TLS_CHACHA20_POLY1305_SHA256
TLS_AES_128_GCM_SHA256
```

### Configuration serveur

```javascript
const https = require('https');
const fs = require('fs');

const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('certificate.pem'),
    minVersion: 'TLSv1.2',
    maxVersion: 'TLSv1.3',
    ciphers: [
        'ECDHE-RSA-AES128-GCM-SHA256',
        'ECDHE-ECDSA-AES128-GCM-SHA256',
        'ECDHE-RSA-AES256-GCM-SHA384',
        'ECDHE-ECDSA-AES256-GCM-SHA384',
        '!aNULL',
        '!eNULL',
        '!EXPORT',
        '!DES',
        '!RC4',
        '!MD5',
        '!PSK',
        '!SRP',
        '!CAMELLIA'
    ].join(':'),
    honorCipherOrder: true,
    secureProtocol: 'TLSv1_2_method'
};

const server = https.createServer(options, (req, res) => {
    res.writeHead(200);
    res.end('Hello HTTPS!');
});

server.listen(443);
```

## HSTS (HTTP Strict Transport Security)

Force les navigateurs à utiliser HTTPS pour un domaine.

### Implémentation

```javascript
const express = require('express');
const helmet = require('helmet');

const app = express();

app.use(helmet.hsts({
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
}));

// Header résultant :
// Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
```

### Directives

- **max-age** : Durée en secondes (recommandé : 31536000 = 1 an)
- **includeSubDomains** : Applique HSTS à tous les sous-domaines
- **preload** : Indique l'éligibilité pour la liste de préchargement HSTS

### Liste de préchargement HSTS

Les navigateurs préchargent une liste de domaines avec HSTS activé.

**Inscription :** https://hstspreload.org/

**Exigences :**
- HSTS avec `includeSubDomains` et `preload`
- Redirection HTTP vers HTTPS
- Certificat valide pour le domaine racine et tous les sous-domaines

## Certificate Pinning

Épingler les certificats pour prévenir les attaques MITM.

### Implémentation côté client

```javascript
const https = require('https');
const crypto = require('crypto');

const pinnedCerts = [
    'sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=',
    'sha256/BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB='
];

function checkPinning(cert) {
    const fingerprint = crypto
        .createHash('sha256')
        .update(cert.raw)
        .digest('base64');
    
    return pinnedCerts.includes(`sha256/${fingerprint}`);
}

const options = {
    hostname: 'api.example.com',
    port: 443,
    path: '/',
    method: 'GET',
    checkServerIdentity: (servername, cert) => {
        if (!checkPinning(cert)) {
            throw new Error('Certificate pinning failed');
        }
        return undefined;
    }
};

https.request(options, (res) => {
    // Requête sécurisée
});
```

### Public Key Pinning (HPKP)

**Note :** HPKP est déprécié et retiré des navigateurs modernes. Utiliser certificate pinning à la place.

## Vulnérabilités TLS

### BEAST (Browser Exploit Against SSL/TLS)

**Affecte :** TLS 1.0 et certaines implémentations de TLS 1.1

**Protection :** Utiliser TLS 1.2+ avec cipher suites AEAD

### POODLE (Padding Oracle On Downgraded Legacy Encryption)

**Affecte :** SSL 3.0

**Protection :** Désactiver SSL 3.0

### FREAK (Factoring Attack on RSA-EXPORT Keys)

**Affecte :** Cipher suites avec clés RSA-EXPORT

**Protection :** Désactiver les cipher suites EXPORT

### Logjam

**Affecte :** Cipher suites DHE avec paramètres faibles

**Protection :** Utiliser des paramètres DHE forts (2048+ bits) ou préférer ECDHE

### DROWN (Decrypting RSA with Obsolete and Weakened eNcryption)

**Affecte :** Serveurs supportant SSL 2.0

**Protection :** Désactiver complètement SSL 2.0

### ROBOT (Return Of Bleichenbacher's Oracle Threat)

**Affecte :** Implémentations RSA PKCS#1 v1.5

**Protection :** Utiliser RSA-OAEP ou préférer ECDHE

### Lucky 13

**Affecte :** Implémentations CBC avec timing attacks

**Protection :** Utiliser des cipher suites AEAD (GCM, ChaCha20-Poly1305)

## Configuration sécurisée

### Nginx

```nginx
server {
    listen 443 ssl http2;
    server_name example.com;
    
    ssl_certificate /path/to/certificate.pem;
    ssl_certificate_key /path/to/private-key.pem;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384';
    ssl_prefer_server_ciphers on;
    
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets off;
    
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /path/to/chain.pem;
}
```

### Apache

```apache
<VirtualHost *:443>
    ServerName example.com
    
    SSLEngine on
    SSLCertificateFile /path/to/certificate.pem
    SSLCertificateKeyFile /path/to/private-key.pem
    SSLCertificateChainFile /path/to/chain.pem
    
    SSLProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1
    SSLCipherSuite ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384
    SSLHonorCipherOrder on
    
    Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
</VirtualHost>
```

### Node.js/Express

```javascript
const express = require('express');
const https = require('https');
const fs = require('fs');
const helmet = require('helmet');

const app = express();

app.use(helmet.hsts({
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
}));

const options = {
    key: fs.readFileSync('private-key.pem'),
    cert: fs.readFileSync('certificate.pem'),
    minVersion: 'TLSv1.2',
    ciphers: [
        'ECDHE-RSA-AES128-GCM-SHA256',
        'ECDHE-ECDSA-AES128-GCM-SHA256',
        'ECDHE-RSA-AES256-GCM-SHA384',
        'ECDHE-ECDSA-AES256-GCM-SHA384',
        '!aNULL',
        '!eNULL',
        '!EXPORT',
        '!DES',
        '!RC4',
        '!MD5'
    ].join(':'),
    honorCipherOrder: true
};

https.createServer(options, app).listen(443);
```

## Tests de configuration

### SSL Labs

Tester la configuration TLS : https://www.ssllabs.com/ssltest/

### Test manuel avec OpenSSL

```bash
# Tester les versions TLS supportées
openssl s_client -connect example.com:443 -tls1_2
openssl s_client -connect example.com:443 -tls1_3

# Lister les cipher suites
openssl s_client -connect example.com:443 -cipher 'ECDHE-RSA-AES128-GCM-SHA256'

# Vérifier le certificat
openssl s_client -connect example.com:443 -showcerts
```

### Test avec nmap

```bash
# Scanner les versions TLS
nmap --script ssl-enum-ciphers -p 443 example.com

# Vérifier les vulnérabilités
nmap --script ssl-heartbleed,ssl-poodle,ssl-ccs-injection -p 443 example.com
```

## Bonnes pratiques

### Checklist de sécurité

- [ ] Utiliser TLS 1.2 minimum, TLS 1.3 recommandé
- [ ] Désactiver SSL 2.0, SSL 3.0, TLS 1.0, TLS 1.1
- [ ] Utiliser uniquement des cipher suites sécurisés
- [ ] Préférer ECDHE pour l'échange de clés
- [ ] Utiliser des cipher suites AEAD (GCM, ChaCha20-Poly1305)
- [ ] Implémenter HSTS avec `includeSubDomains` et `preload`
- [ ] Activer OCSP stapling
- [ ] Désactiver les sessions TLS réutilisables (session tickets)
- [ ] Utiliser des certificats valides émis par une CA de confiance
- [ ] Renouveler les certificats avant expiration
- [ ] Tester régulièrement la configuration (SSL Labs)
- [ ] Monitorer les connexions TLS
- [ ] Documenter la configuration TLS
- [ ] Former l'équipe sur TLS

## Conclusion

HTTPS/TLS est essentiel pour la sécurité web moderne. Une configuration correcte, l'utilisation de versions récentes et de cipher suites sécurisés, combinés à HSTS et un monitoring approprié, offrent une protection robuste contre les attaques.

## Références techniques

- [RFC 8446 - TLS 1.3](https://tools.ietf.org/html/rfc8446)
- [RFC 5246 - TLS 1.2](https://tools.ietf.org/html/rfc5246)
- [RFC 6797 - HSTS](https://tools.ietf.org/html/rfc6797)
- [Mozilla SSL Configuration Generator](https://ssl-config.mozilla.org/)
- [SSL Labs](https://www.ssllabs.com/)
- [OWASP Transport Layer Protection Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Protection_Cheat_Sheet.html)
