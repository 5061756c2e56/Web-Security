---
title: "Shamir Secret Sharing"
category: "cryptography"
description: "Guide sur le partage de secret de Shamir : mathématiques détaillées, interpolation polynomiale de Lagrange, seuil de récupération, sécurité informationnelle parfaite, implémentations complètes, cas d'usage et bonnes pratiques."
coverImage: "/guides/shamir.jpg"
date: "2024-03-05"
difficulty: "avancé"
readingTime: "40 min"
prerequisites: ["Mathématiques", "Cryptographie", "Polynômes"]
lastUpdated: "2024-12-19"
---

# Shamir Secret Sharing

Le partage de secret de Shamir est un algorithme cryptographique permettant de diviser un secret en plusieurs parts (shares) de telle sorte qu'un seuil minimum de parts est nécessaire pour reconstruire le secret original. C'est une technique puissante pour sécuriser des informations critiques.

## Introduction

Au lieu de stocker un secret complet en un seul endroit, on le divise en n parts. Seulement k parts (k ≤ n) sont nécessaires pour reconstruire le secret. Moins de k parts ne révèlent aucune information sur le secret.

**Avantages :**
- Aucune partie ne connaît le secret complet
- Résistant aux compromissions partielles
- Flexible : peut ajuster n et k selon les besoins
- Sécurité informationnelle parfaite

## Principe

### Concept

Imaginez une clé de coffre-fort. Au lieu d'avoir une seule clé, vous créez 5 copies et les distribuez à 5 personnes. Le système est configuré pour que 3 personnes minimum doivent être présentes pour ouvrir le coffre. C'est le principe du partage de secret avec n=5 et k=3.

### Paramètres

- **n** : Nombre total de parts générées
- **k** : Seuil minimum de parts nécessaires (threshold)
- **Secret** : La donnée à partager

## Mathématiques

### Interpolation polynomiale

Shamir utilise l'interpolation polynomiale de Lagrange. Un polynôme de degré (k-1) est créé, où :

- Le secret est le terme constant du polynôme
- k points du polynôme sont nécessaires pour le reconstruire
- Moins de k points ne révèlent aucune information

### Exemple simplifié

Pour un secret S avec k=3 et n=5 :

1. Créer un polynôme : f(x) = S + a₁x + a₂x²
2. Générer 5 points : (1, f(1)), (2, f(2)), ..., (5, f(5))
3. Chaque point est une "part"
4. N'importe quels 3 points permettent de reconstruire le polynôme et donc S

### Formule de Lagrange

Pour reconstruire le secret à partir de k points :

```
f(0) = Σ (yᵢ × Π (xⱼ / (xⱼ - xᵢ)))
       i=1  j≠i
```

## Sécurité

### Sécurité informationnelle parfaite

Avec moins de k parts, aucune information sur le secret n'est révélée. C'est une propriété mathématique garantie, pas une hypothèse de sécurité.

**Preuve :** Pour k-1 points, il existe un nombre infini de polynômes de degré k-1 passant par ces points, chacun avec un terme constant différent (le secret).

### Avantages

- Aucune partie ne connaît le secret complet
- Résistant aux compromissions partielles
- Flexible : peut ajuster n et k selon les besoins
- Sécurité mathématique garantie

### Limitations

- Si k parts sont compromises, le secret est révélé
- Nécessite une distribution sécurisée des parts
- Complexité de gestion augmente avec n
- Nécessite des calculs mathématiques

## Cas d'usage

### Gestion de clés cryptographiques

Partager une clé maître entre plusieurs administrateurs. Exige la présence de plusieurs personnes pour utiliser la clé.

```javascript
class KeySharingService {
    async shareMasterKey(masterKey, n, k) {
        const shares = await this.generateShares(masterKey, n, k);
        
        const administrators = await this.getAdministrators();
        for (let i = 0; i < n; i++) {
            await this.distributeShare(administrators[i], shares[i]);
        }
    }
    
    async reconstructMasterKey(shares) {
        if (shares.length < this.threshold) {
            throw new Error('Insufficient shares');
        }
        
        return await this.reconstructSecret(shares);
    }
}
```

### Sauvegarde de secrets

Créer des sauvegardes redondantes d'un secret. Même si certaines parts sont perdues, le secret peut être récupéré.

```javascript
async function backupSecret(secret, n, k) {
    const shares = await generateShares(secret, n, k);
    
    const backupLocations = [
        'location1',
        'location2',
        'location3',
        'location4',
        'location5'
    ];
    
    for (let i = 0; i < n; i++) {
        await storeShare(backupLocations[i], shares[i]);
    }
}
```

### Contrôle d'accès distribué

Systèmes où plusieurs parties doivent collaborer pour accéder à une ressource sensible.

### Blockchain et cryptomonnaies

Utilisé dans certains wallets multi-signatures pour sécuriser les clés privées.

## Implémentation

### Génération des parts

```javascript
const secrets = require('secrets.js-grempe');

class ShamirSecretSharing {
    share(secret, n, k) {
        const hexSecret = Buffer.from(secret).toString('hex');
        const shares = secrets.share(hexSecret, n, k);
        return shares;
    }
    
    combine(shares) {
        if (shares.length < this.getThreshold(shares[0])) {
            throw new Error('Insufficient shares');
        }
        
        const hexSecret = secrets.combine(shares);
        return Buffer.from(hexSecret, 'hex').toString('utf8');
    }
    
    getThreshold(share) {
        const shareData = secrets.extractShareComponents(share);
        return shareData[0];
    }
}
```

### Implémentation complète

```javascript
const secrets = require('secrets.js-grempe');
const crypto = require('crypto');

class SecureSecretSharing {
    constructor() {
        this.prime = secrets.init();
    }
    
    share(secret, n, k) {
        if (k > n) {
            throw new Error('Threshold cannot exceed number of shares');
        }
        
        if (k < 2) {
            throw new Error('Threshold must be at least 2');
        }
        
        const hexSecret = Buffer.from(secret).toString('hex');
        const shares = secrets.share(hexSecret, n, k);
        
        return shares.map((share, index) => ({
            id: index + 1,
            share: share,
            checksum: this.calculateChecksum(share)
        }));
    }
    
    combine(shares) {
        const shareStrings = shares.map(s => s.share || s);
        
        if (shareStrings.length < 2) {
            throw new Error('At least 2 shares required');
        }
        
        const threshold = this.getThreshold(shareStrings[0]);
        if (shareStrings.length < threshold) {
            throw new Error(`At least ${threshold} shares required`);
        }
        
        for (const share of shares) {
            if (share.checksum) {
                const calculated = this.calculateChecksum(share.share);
                if (calculated !== share.checksum) {
                    throw new Error('Share integrity check failed');
                }
            }
        }
        
        const hexSecret = secrets.combine(shareStrings);
        return Buffer.from(hexSecret, 'hex').toString('utf8');
    }
    
    calculateChecksum(share) {
        return crypto.createHash('sha256')
            .update(share)
            .digest('hex')
            .substring(0, 8);
    }
    
    getThreshold(share) {
        const components = secrets.extractShareComponents(share);
        return components[0];
    }
}
```

### Distribution sécurisée

```javascript
class ShareDistribution {
    async distributeShares(shares, recipients) {
        if (shares.length !== recipients.length) {
            throw new Error('Number of shares must match number of recipients');
        }
        
        const encryptedShares = [];
        
        for (let i = 0; i < shares.length; i++) {
            const recipient = recipients[i];
            const encrypted = await this.encryptShare(
                shares[i],
                recipient.publicKey
            );
            
            await this.sendShare(recipient, encrypted);
            encryptedShares.push(encrypted);
        }
        
        return encryptedShares;
    }
    
    async encryptShare(share, publicKey) {
        const { publicEncrypt } = require('crypto');
        return publicEncrypt(publicKey, Buffer.from(share));
    }
}
```

## Bonnes pratiques

### Checklist de sécurité

- [ ] Choisir k et n selon les besoins de sécurité
- [ ] Distribuer les parts via des canaux sécurisés différents
- [ ] Stocker les parts dans des emplacements physiques séparés
- [ ] Ne jamais stocker toutes les parts au même endroit
- [ ] Valider l'intégrité des parts avant reconstruction
- [ ] Utiliser des bibliothèques cryptographiques réputées
- [ ] Implémenter des checksums pour vérifier l'intégrité
- [ ] Chiffrer les parts lors de la distribution
- [ ] Documenter la configuration (n, k)
- [ ] Former les participants sur le processus
- [ ] Tester la reconstruction régulièrement
- [ ] Avoir un plan de récupération d'urgence
- [ ] Monitorer l'accès aux parts
- [ ] Implémenter la rotation des secrets si nécessaire

### Choix de n et k

**Recommandations :**
- **n = 5, k = 3** : Bon compromis sécurité/accessibilité
- **n = 7, k = 4** : Sécurité renforcée
- **n = 9, k = 5** : Très haute sécurité

**Règle :** k doit être au moins la moitié de n pour une sécurité optimale.

## Exemple d'utilisation complète

```javascript
const sharingService = new SecureSecretSharing();

// Partager un secret
const secret = "MySecretKey123";
const shares = sharingService.share(secret, 5, 3);

console.log(`Secret partagé en 5 parts, 3 nécessaires pour reconstruction`);

// Distribuer les parts
const recipients = [
    { id: 1, name: 'Admin 1' },
    { id: 2, name: 'Admin 2' },
    { id: 3, name: 'Admin 3' },
    { id: 4, name: 'Admin 4' },
    { id: 5, name: 'Admin 5' }
];

await distributeShares(shares, recipients);

// Reconstruction (nécessite 3 parts minimum)
const collectedShares = [
    shares[0],
    shares[1],
    shares[2]
];

const reconstructed = sharingService.combine(collectedShares);
console.log(reconstructed === secret); // true
```

## Conclusion

Shamir Secret Sharing est une technique puissante pour sécuriser des secrets critiques en les distribuant de manière sécurisée. Sa sécurité mathématique garantie en fait un outil précieux pour la gestion de clés et la protection de données sensibles. Une implémentation correcte avec distribution sécurisée et validation d'intégrité offre une protection robuste.

## Références techniques

- [Shamir, A. (1979). How to share a secret](https://web.mit.edu/6.857/OldStuff/Fall03/ref/Shamir-HowToShareASecret.pdf)
- [RFC 8446 - TLS 1.3](https://tools.ietf.org/html/rfc8446)
- [secrets.js Library](https://github.com/grempe/secrets.js)
