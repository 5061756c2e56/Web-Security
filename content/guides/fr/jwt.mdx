---
title: "JSON Web Tokens (JWT) de sécurité"
category: "cryptography"
description: "Guide sur les JWT : structure détaillée, algorithmes de signature (HS256, RS256, ES256), vulnérabilités avancées (algorithm confusion, kid injection, weak secrets), implémentations sécurisées, refresh tokens, bonnes pratiques et outils de test."
coverImage: "/guides/jwt.jpg"
date: "2024-03-01"
difficulty: "avancé"
readingTime: "40 min"
prerequisites: ["Cryptographie", "Authentification", "JSON"]
lastUpdated: "2024-12-19"
---

# JSON Web Tokens (JWT) de sécurité

Les JSON Web Tokens (JWT) sont un standard ouvert (RFC 7519) pour transmettre de manière sécurisée des informations entre parties sous forme d'objet JSON. Ils sont largement utilisés pour l'authentification et l'autorisation dans les applications web modernes, mais leur sécurité dépend entièrement d'une implémentation correcte.

## Introduction

JWT permet de transmettre des claims (revendications) de manière compacte et sécurisée. Contrairement aux sessions traditionnelles, les JWT sont stateless, ce qui les rend adaptés aux architectures distribuées et microservices.

**Avantages :**
- Stateless : Pas besoin de stockage serveur
- Portable : Utilisable sur plusieurs domaines
- Compact : Format URL-safe
- Standardisé : RFC 7519

**Inconvénients :**
- Révocation difficile
- Taille limitée
- Données exposées (Base64, pas chiffré)
- Pas de révocation native

## Structure d'un JWT

Un JWT est composé de trois parties séparées par des points (.) :

```
header.payload.signature
```

### Header (En-tête)

Contient les métadonnées sur le token.

```json
{
  "alg": "HS256",
  "typ": "JWT",
  "kid": "key-id-123"
}
```

**Champs courants :**
- `alg` : Algorithme de signature (requis)
- `typ` : Type de token (généralement "JWT")
- `kid` : Key ID pour identifier la clé
- `cty` : Content Type (pour JWT imbriqués)

### Payload (Charge utile)

Contient les claims (revendications).

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622,
  "iss": "https://myapp.com",
  "aud": "myapp"
}
```

**Types de claims :**

#### Registered Claims (Revendications enregistrées)

Claims prédéfinis dans la spécification :

- `iss` (issuer) : Émetteur du token
- `sub` (subject) : Sujet du token (généralement l'ID utilisateur)
- `aud` (audience) : Audience cible
- `exp` (expiration) : Date d'expiration (timestamp)
- `nbf` (not before) : Date de validité (timestamp)
- `iat` (issued at) : Date d'émission (timestamp)
- `jti` (JWT ID) : Identifiant unique du token

#### Public Claims

Claims définis publiquement ou enregistrés dans l'IANA JWT Claims Registry.

#### Private Claims

Claims personnalisés pour un usage spécifique.

### Signature

Permet de vérifier l'intégrité et l'authenticité du token.

```javascript
const crypto = require('crypto');

function signJWT(header, payload, secret) {
    const encodedHeader = base64UrlEncode(JSON.stringify(header));
    const encodedPayload = base64UrlEncode(JSON.stringify(payload));
    
    const data = `${encodedHeader}.${encodedPayload}`;
    const signature = crypto
        .createHmac('sha256', secret)
        .update(data)
        .digest('base64url');
    
    return `${data}.${signature}`;
}
```

## Algorithmes de signature

### HS256 (HMAC avec SHA-256)

Signature symétrique utilisant une clé secrète partagée.

```javascript
const jwt = require('jsonwebtoken');

const secret = crypto.randomBytes(64).toString('hex');

const token = jwt.sign(
    { userId: '123', role: 'user' },
    secret,
    {
        algorithm: 'HS256',
        expiresIn: '1h',
        issuer: 'myapp.com',
        audience: 'myapp'
    }
);

const decoded = jwt.verify(token, secret, {
    algorithms: ['HS256'],
    issuer: 'myapp.com',
    audience: 'myapp'
});
```

**Avantages :**
- Simple à implémenter
- Performant
- Pas besoin de gestion de clés publiques/privées

**Inconvénients :**
- Nécessite un partage sécurisé de la clé
- Tous les services doivent connaître la clé secrète
- Compromission de la clé = compromission totale

### RS256 (RSA avec SHA-256)

Signature asymétrique utilisant une paire de clés RSA.

```javascript
const fs = require('fs');
const jwt = require('jsonwebtoken');

const privateKey = fs.readFileSync('private-key.pem', 'utf8');
const publicKey = fs.readFileSync('public-key.pem', 'utf8');

const token = jwt.sign(
    { userId: '123', role: 'user' },
    privateKey,
    {
        algorithm: 'RS256',
        expiresIn: '1h'
    }
);

const decoded = jwt.verify(token, publicKey, {
    algorithms: ['RS256']
});
```

**Avantages :**
- Seul le serveur possède la clé privée
- Distribution facile de la clé publique
- Plus sécurisé pour les architectures distribuées
- Révocation possible via rotation de clés

**Inconvénients :**
- Plus lent que HS256
- Nécessite une gestion de clés plus complexe
- Clés plus longues

### ES256 (ECDSA avec P-256 et SHA-256)

Signature asymétrique utilisant les courbes elliptiques.

```javascript
const token = jwt.sign(
    { userId: '123', role: 'user' },
    privateKey,
    {
        algorithm: 'ES256',
        expiresIn: '1h'
    }
);

const decoded = jwt.verify(token, publicKey, {
    algorithms: ['ES256']
});
```

**Avantages :**
- Clés plus courtes que RSA pour la même sécurité
- Performances meilleures que RSA
- Standard moderne
- Forward secrecy possible

**Inconvénients :**
- Support moins universel que RSA
- Gestion de clés plus complexe

### Comparaison des algorithmes

| Algorithme | Type | Sécurité | Performance | Recommandation |
|------------|------|----------|-------------|----------------|
| HS256 | Symétrique | Bonne | Excellente | Microservices internes |
| RS256 | Asymétrique | Excellente | Bonne | APIs publiques |
| ES256 | Asymétrique | Excellente | Excellente | **Recommandé** |

## Vulnérabilités courantes

### 1. Algorithm Confusion (alg=none)

Si l'application accepte `"alg": "none"`, un attaquant peut créer un token sans signature.

```javascript
// Vulnérable
const decoded = jwt.verify(token, secret);

// Attaque
const maliciousToken = base64UrlEncode({
    alg: 'none',
    typ: 'JWT'
}) + '.' + base64UrlEncode({
    userId: 'admin',
    role: 'admin'
}) + '.';

// Protection : Spécifier explicitement les algorithmes
const decoded = jwt.verify(token, secret, {
    algorithms: ['HS256', 'RS256', 'ES256']
});
```

### 2. Algorithm Substitution (HS256 vs RS256)

Si l'application accepte plusieurs algorithmes et utilise la clé publique pour vérifier HS256.

```javascript
// Vulnérable : Utilise la clé publique pour HS256
const decoded = jwt.verify(token, publicKey, {
    algorithms: ['HS256', 'RS256']
});

// Attaque : Créer un token HS256 signé avec la clé publique
const maliciousToken = jwt.sign(
    { userId: 'admin' },
    publicKey,
    { algorithm: 'HS256' }
);

// Protection : Séparer la vérification selon l'algorithme
function verifyToken(token, secret, publicKey) {
    const decoded = jwt.decode(token, { complete: true });
    
    if (decoded.header.alg === 'HS256') {
        return jwt.verify(token, secret, { algorithms: ['HS256'] });
    } else if (decoded.header.alg === 'RS256') {
        return jwt.verify(token, publicKey, { algorithms: ['RS256'] });
    } else {
        throw new Error('Unsupported algorithm');
    }
}
```

### 3. Weak Secret Key

Si la clé secrète est faible ou prévisible, elle peut être devinée par force brute.

```javascript
// Vulnérable
const secret = 'mySecretKey123';

// Sécurisé
const secret = crypto.randomBytes(64).toString('hex');

// Protection : Validation de la force de la clé
function validateSecret(secret) {
    if (secret.length < 32) {
        throw new Error('Secret too short');
    }
    
    const entropy = calculateEntropy(secret);
    if (entropy < 128) {
        throw new Error('Secret entropy too low');
    }
    
    return true;
}
```

### 4. kid Injection

Si le paramètre `kid` (Key ID) n'est pas correctement validé, un attaquant peut pointer vers une clé malveillante.

```javascript
// Vulnérable
function getKey(kid) {
    return db.getKey(kid);
}

// Attaque : kid = "../../../etc/passwd"
// Attaque : kid = "malicious-key-id"

// Protection : Validation stricte
function getKey(kid) {
    if (!/^[a-zA-Z0-9_-]+$/.test(kid)) {
        throw new Error('Invalid key ID');
    }
    
    const allowedKeys = ['key-1', 'key-2', 'key-3'];
    if (!allowedKeys.includes(kid)) {
        throw new Error('Key ID not in whitelist');
    }
    
    return db.getKey(kid);
}
```

### 5. Expiration Non Vérifiée

Si `exp` n'est pas vérifié, des tokens expirés peuvent être réutilisés.

```javascript
// Vulnérable
const decoded = jwt.decode(token);

// Protection : Vérification automatique avec jwt.verify
const decoded = jwt.verify(token, secret, {
    algorithms: ['HS256'],
    maxAge: '1h'
});
```

### 6. Sensitive Data in Payload

Les données sensibles ne doivent jamais être stockées dans le payload car il est encodé en Base64 (pas chiffré).

```javascript
// Vulnérable
const token = jwt.sign({
    userId: '123',
    password: 'secret123',
    creditCard: '4532-1234-5678-9010'
}, secret);

// Sécurisé : Ne stocker que des identifiants
const token = jwt.sign({
    userId: '123',
    role: 'user'
}, secret);
```

### 7. jku (JSON Web Key Set URL) Injection

Si `jku` n'est pas validé, un attaquant peut pointer vers son propre JWKS.

```javascript
// Vulnérable
const jwks = await fetch(decoded.header.jku);

// Protection : Whitelist des URLs
const allowedJWKSUrls = [
    'https://myapp.com/.well-known/jwks.json'
];

if (!allowedJWKSUrls.includes(decoded.header.jku)) {
    throw new Error('JWKS URL not allowed');
}
```

## Implémentations sécurisées

### Service JWT complet

```javascript
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

class SecureJWTService {
    constructor(secret, publicKey, privateKey) {
        this.secret = secret;
        this.publicKey = publicKey;
        this.privateKey = privateKey;
        this.allowedAlgorithms = ['HS256', 'RS256', 'ES256'];
    }
    
    generateToken(payload, options = {}) {
        const tokenPayload = {
            ...payload,
            iat: Math.floor(Date.now() / 1000),
            jti: crypto.randomBytes(16).toString('hex')
        };
        
        const tokenOptions = {
            algorithm: options.algorithm || 'HS256',
            expiresIn: options.expiresIn || '1h',
            issuer: options.issuer || 'myapp.com',
            audience: options.audience || 'myapp',
            ...options
        };
        
        const key = tokenOptions.algorithm.startsWith('HS') 
            ? this.secret 
            : this.privateKey;
        
        return jwt.sign(tokenPayload, key, tokenOptions);
    }
    
    verifyToken(token, options = {}) {
        const decoded = jwt.decode(token, { complete: true });
        
        if (!decoded) {
            throw new Error('Invalid token format');
        }
        
        if (!this.allowedAlgorithms.includes(decoded.header.alg)) {
            throw new Error('Algorithm not allowed');
        }
        
        const key = decoded.header.alg.startsWith('HS')
            ? this.secret
            : this.publicKey;
        
        return jwt.verify(token, key, {
            algorithms: this.allowedAlgorithms,
            issuer: options.issuer || 'myapp.com',
            audience: options.audience || 'myapp',
            ...options
        });
    }
    
    async isTokenRevoked(token) {
        const decoded = jwt.decode(token);
        const jti = decoded.jti;
        
        return await db.isTokenRevoked(jti);
    }
    
    async revokeToken(token) {
        const decoded = jwt.decode(token);
        const jti = decoded.jti;
        const exp = decoded.exp;
        
        await db.revokeToken(jti, exp);
    }
}
```

### Refresh Tokens

```javascript
class TokenService {
    generateAccessToken(user) {
        return jwt.sign(
            {
                userId: user.id,
                role: user.role,
                type: 'access'
            },
            process.env.JWT_SECRET,
            {
                algorithm: 'HS256',
                expiresIn: '15m',
                issuer: 'myapp.com'
            }
        );
    }
    
    generateRefreshToken(userId) {
        return jwt.sign(
            {
                userId: userId,
                type: 'refresh',
                jti: crypto.randomBytes(16).toString('hex')
            },
            process.env.JWT_REFRESH_SECRET,
            {
                algorithm: 'HS256',
                expiresIn: '7d',
                issuer: 'myapp.com'
            }
        );
    }
    
    async refreshAccessToken(refreshToken) {
        const decoded = jwt.verify(
            refreshToken,
            process.env.JWT_REFRESH_SECRET,
            { algorithms: ['HS256'] }
        );
        
        if (decoded.type !== 'refresh') {
            throw new Error('Invalid token type');
        }
        
        const isRevoked = await db.isTokenRevoked(decoded.jti);
        if (isRevoked) {
            throw new Error('Token revoked');
        }
        
        const user = await db.getUser(decoded.userId);
        return this.generateAccessToken(user);
    }
}
```

### Middleware d'authentification

```javascript
function authenticateJWT(req, res, next) {
    const authHeader = req.headers.authorization;
    
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'Missing or invalid authorization header' });
    }
    
    const token = authHeader.substring(7);
    const jwtService = new SecureJWTService(
        process.env.JWT_SECRET,
        process.env.JWT_PUBLIC_KEY,
        process.env.JWT_PRIVATE_KEY
    );
    
    try {
        const decoded = jwtService.verifyToken(token);
        
        jwtService.isTokenRevoked(token)
            .then(revoked => {
                if (revoked) {
                    return res.status(401).json({ error: 'Token revoked' });
                }
                
                req.user = decoded;
                next();
            })
            .catch(error => {
                res.status(401).json({ error: 'Token verification failed' });
            });
    } catch (error) {
        res.status(401).json({ error: 'Invalid token' });
    }
}
```

## Stockage côté client

### Cookies HttpOnly (Recommandé)

```javascript
res.cookie('token', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 15 * 60 * 1000
});
```

**Avantages :**
- Protégé contre XSS
- Envoyé automatiquement
- Contrôle par le serveur

**Inconvénients :**
- Limité par la taille des cookies
- CSRF possible (mitigé par SameSite)

### localStorage

```javascript
localStorage.setItem('token', token);
```

**Avantages :**
- Pas de limite de taille
- Persistant

**Inconvénients :**
- Vulnérable à XSS
- Accessible via JavaScript
- Pas de contrôle serveur

### sessionStorage

```javascript
sessionStorage.setItem('token', token);
```

**Avantages :**
- Pas de limite de taille
- Supprimé à la fermeture de l'onglet

**Inconvénients :**
- Vulnérable à XSS
- Accessible via JavaScript

## Rotation des clés

```javascript
class KeyRotationService {
    constructor() {
        this.currentKeyId = 'key-1';
        this.keys = {
            'key-1': process.env.JWT_SECRET_1,
            'key-2': process.env.JWT_SECRET_2
        };
    }
    
    getKey(kid) {
        if (!kid) {
            return this.keys[this.currentKeyId];
        }
        
        if (!this.keys[kid]) {
            throw new Error('Key not found');
        }
        
        return this.keys[kid];
    }
    
    rotateKeys() {
        const newKey = crypto.randomBytes(64).toString('hex');
        const newKeyId = 'key-2';
        
        this.keys[newKeyId] = newKey;
        this.currentKeyId = newKeyId;
        
        return newKeyId;
    }
    
    verifyTokenWithRotation(token) {
        const decoded = jwt.decode(token, { complete: true });
        const kid = decoded.header.kid || this.currentKeyId;
        
        try {
            const key = this.getKey(kid);
            return jwt.verify(token, key, { algorithms: ['HS256'] });
        } catch (error) {
            if (kid !== this.currentKeyId) {
                const currentKey = this.getKey(this.currentKeyId);
                return jwt.verify(token, currentKey, { algorithms: ['HS256'] });
            }
            throw error;
        }
    }
}
```

## Outils de test

### jwt.io

Plateforme en ligne pour décoder et tester les JWT.

### jwt_tool

```bash
python3 jwt_tool.py <JWT_TOKEN>

# Test algorithm confusion
python3 jwt_tool.py <JWT_TOKEN> -X a

# Test kid injection
python3 jwt_tool.py <JWT_TOKEN> -X i

# Brute force secret
python3 jwt_tool.py <JWT_TOKEN> -C -d wordlist.txt
```

### Burp Suite

Extension JWT Editor pour manipuler et tester les JWT.

## Bonnes pratiques

### Checklist de sécurité

- [ ] Utiliser des algorithmes sécurisés (HS256, RS256, ES256)
- [ ] Spécifier explicitement les algorithmes autorisés
- [ ] Utiliser des clés secrètes fortes (minimum 256 bits)
- [ ] Vérifier tous les claims (exp, iss, aud, nbf)
- [ ] Inclure un jti unique pour chaque token
- [ ] Ne jamais stocker de données sensibles dans le payload
- [ ] Implémenter la révocation de tokens
- [ ] Utiliser des tokens avec expiration courte (15 minutes)
- [ ] Implémenter les refresh tokens pour les sessions longues
- [ ] Valider strictement le kid si utilisé
- [ ] Whitelist des jku si utilisé
- [ ] Stocker les tokens dans des cookies HttpOnly
- [ ] Implémenter la rotation des clés
- [ ] Logger les tentatives d'authentification
- [ ] Monitorer les tokens invalides
- [ ] Tester régulièrement avec des outils de sécurité

## Conclusion

Les JWT sont un outil puissant pour l'authentification et l'autorisation, mais leur sécurité dépend entièrement d'une implémentation correcte. Il est essentiel de comprendre les vulnérabilités courantes, d'utiliser des algorithmes sécurisés, de valider tous les claims, et d'implémenter des mécanismes de révocation et de rotation des clés.

## Références techniques

- [RFC 7519 - JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
- [RFC 7515 - JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515)
- [RFC 7517 - JSON Web Key (JWK)](https://tools.ietf.org/html/rfc7517)
- [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)
- [jwt.io](https://jwt.io/)
- [PortSwigger Web Security Academy - JWT](https://portswigger.net/web-security/jwt)
